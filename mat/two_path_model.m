%% ripple_model_old_theory_beam_reflection_grid
% -------------------------------------------------------------------------
% PURPOSE
%   Demonstrate a “two-path interference at the receiver” model in which a
%   bat call reaches a shoreline microphone via:
%     (1) a direct arrival, and
%     (2) a surface-reflected arrival (specular reflection),
%   producing spectral ripples through the inter-path delay Δτ = dt.
%
%   The script sweeps bat height (h) and beam angle (θ) to map when a
%   surface-reflection is geometrically feasible and how the resulting
%   delay shapes the ripple pattern. Output is a tiled grid of spectrograms:
%     - rows: bat height h (0.1–1.0 m)
%     - cols: beam angle θ (5–45° below horizontal)
%
% -------------------------------------------------------------------------
% GEOMETRY / ASSUMPTIONS
%   - Flat reflecting surface (e.g. water) between bat and a fixed microphone
%     at horizontal range shore_dist.
%   - The bat emits along an axis pitched downward by θ (beam_angle_deg).
%   - The specular reflection point is where the emitted ray intersects the
%     surface:
%         x_r = h / tan(θ)
%
%   Path decomposition:
%     a : slant path bat → reflection point
%         a = h / sin(θ)
%     b : horizontal path reflection point → microphone (along surface)
%         b = shore_dist − x_r
%
%   If b <= 0, the reflection point lies beyond the microphone (or behind it),
%   so this geometry does not produce a valid surface-reflected arrival for
%   the chosen θ and h. In that case the script plots the original call only.
%
% -------------------------------------------------------------------------
% DIRECT vs REFLECTED PATHS
%   Reflected total path length:
%       L_refl = a + b
%
%   Direct path length:
%       L_dir is computed via the law of cosines using the included angle
%       between the bat→reflection and reflection→mic segments. With the
%       chosen geometry, the relevant angle is (π − 2θ):
%
%       L_dir = sqrt( a^2 + b^2 − 2ab cos(π − 2θ) )
%
%   Path difference and delay:
%       ΔL = L_refl − L_dir
%       dt = ΔL / c
%
%   Two-path interference is implemented by delaying a copy of the call by
%   round(fs * dt) samples and averaging:
%       indirect_call = circshift(call, round(fs * dt))
%       overlap_call  = mean([call indirect_call], 2)
%
% -------------------------------------------------------------------------
% SIGNAL / SPECTROGRAM
%   - call: synthetic FM sweep (25–90 kHz, 5 ms) generated by
%           generateVirtualBatCall(...).
%   - img_spec is used to plot a spectrogram in each tile with:
%         window = 128, overlap = 127, nfft = 4096, range = 100
%
%   The ripple spacing in frequency is governed primarily by dt
%   (smaller dt → wider spacing; larger dt → tighter ripples).
%
% -------------------------------------------------------------------------
% GRID VISUALISATION
%   Layout:
%     tiledlayout(length(heights), length(beam_angles_deg))
%
%   Labelling policy (reduced clutter):
%     - Top row: titles show beam angle (θ)
%     - First column: row labels show height (h)
%     - Last column: frequency ticks labelled in kHz (right-hand y-axis)
%     - Bottom row: time ticks labelled in ms
%
%   In-tile annotations:
%     - Red “X”  : b <= 0, reflection geometry invalid → original call plotted
%     - Blue “*” : dt < 0.0004 s (very small delay → weak/very wide ripples),
%                 flagged to highlight near-degenerate two-path conditions.
%
% -------------------------------------------------------------------------
% PARAMETERS
%   heights          : 0.1:0.1:1.0 m
%   beam_angles_deg  : 5:5:45 degrees below horizontal
%   shore_dist       : 10 m (fixed microphone range)
%   c                : 343 m/s
%   fs               : 192 kHz
%
%   fig_path         : output directory for saving (saveFigure call on/off)
%
% -------------------------------------------------------------------------
% OUTPUT
%   - Figure titled:
%       'Overlapped Bat Calls: Beam Reflection Model'
%   - Intended save target (commented):
%       saveFigure(f1, fig_path, 'ripple_model_old_theory_gray')
%
% -------------------------------------------------------------------------
% DEPENDENCIES
%   - generateVirtualBatCall.m
%   - img_spec.m
%   - saveFigure.m (optional; currently commented)
%
% -------------------------------------------------------------------------
% NOTES / CAVEATS
%   - circshift applies a circular shift (wrap-around). For a physically
%     correct delayed arrival you may prefer zero-padding delay instead of
%     wrap-around to avoid injecting energy at the start of the waveform.
%   - The “direct path” computation is a geometric surrogate consistent with
%     the chosen construction (a, b, θ). If you later refactor the geometry
%     (e.g., explicit bat/mic coordinates), recompute L_dir from coordinates
%     for clarity and reduced risk of angle mistakes.
% -------------------------------------------------------------------------

fig_path = '../fig';

% Parameters
heights = 0.1:0.1:1.0;               % Bat height in metres (rows)
beam_angles_deg = 5:5:45;         % Angle below horizontal (degrees)
shore_dist = 10;                     % Horizontal distance to microphone (m)

c = 343;                             % Speed of sound (m/s)
fs = 192e3;                          % Sample rate
call = generateVirtualBatCall(25e3, 90e3, 0.005, fs, 70);

% Create figure
f1 = figure;
sgtitle('Overlapped Bat Calls: Beam Reflection Model');

% Grid layout: rows = heights, cols = beam angles
tl = tiledlayout(length(heights), length(beam_angles_deg), ...
    'TileSpacing', 'compact', 'Padding', 'compact');

for hi = 1:length(heights)
    h = heights(hi);  % Bat height

    for ai = 1:length(beam_angles_deg)
        beam_angle_deg = beam_angles_deg(ai);
        beam_angle_rad = deg2rad(beam_angle_deg);

        % Compute geometry
        x_r = h / tan(beam_angle_rad);        % Horizontal distance to reflection point
        a = h / sin(beam_angle_rad);          % Slant path from bat to reflection point
        b = shore_dist - x_r;                 % Reflection point to mic

        if b <= 0
            % No reflection possible, just plot original call
            overlap_call = call;
        else
            % Compute direct and indirect path
            direct_path = sqrt(a^2 + b^2 - 2*a*b*cos(pi - 2*beam_angle_rad));
            total_path = a + b;
            dd = total_path - direct_path;
            dt = dd / c;

            % Overlapped call with delayed echo
            indirect_call = circshift(call, round(fs * dt));
            overlap_call = mean([call indirect_call], 2);
        end
        % Plot
        nexttileHandle = nexttile;
        img_spec(overlap_call, 128, 127, 4096, fs, 100);
        hold on

        axis square



        ax = gca;


        % Plot in axes-relative units
        ax = gca;
        if b <= 0
            text(ax, 0.95, 0.95, 'X', ...
                'Units', 'normalized', ...
                'Color', 'red', 'FontSize', 14, 'FontWeight', 'bold', ...
                'HorizontalAlignment', 'right', 'VerticalAlignment', 'top');
        elseif dt < 0.0004
            text(ax, 0.95, 0.95, '*', ...
                'Units', 'normalized', ...
                'Color', 'blue', 'FontSize', 14, 'FontWeight', 'bold', ...
                'HorizontalAlignment', 'right', 'VerticalAlignment', 'top');
        end

        % Top row: column title = beam angle
        if hi == 1
            title(sprintf('\\theta = %d^\\circ', beam_angle_deg), 'FontSize', 12, 'FontWeight', 'bold');
        else
            title('');
        end

        % First column: row label = height
        if ai == 1
            ylabel(sprintf('h = %.1fm', h), 'FontSize', 12, ...
                'Rotation', 0, 'HorizontalAlignment', 'right');
            ax.YAxisLocation = 'left';
        else
            ax.YTickLabel = [];
        end

        % Last column: Y axis ticks
        if ai == length(beam_angles_deg)
            ax.YAxisLocation = 'right';
            ax.YTickLabel = ax.YTick ./ 1000;
            ylabel('kHz');
        else
            ax.YTickLabel = [];
        end

        % Bottom row: X axis ticks
        if hi == length(heights)
            xlabel('ms', 'FontSize', 12);
            ax.XTickLabel = ax.XTick .* 1000;
        else
            ax.XTickLabel = [];
        end
    end
end

% Save figure
saveFigure(f1, fig_path, 'ripple_model_old_theory_gray')

